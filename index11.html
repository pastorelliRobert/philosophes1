<!DOCTYPE html>
<html>

<head>

	<meta charset="UTF-8">
	<title>Philosophes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     

	<style>
			
		/* Conteneur principal qui regroupe la liste et le graphe */
		#layout-container {
			display: flex;
			/* Active le mod√®le flexbox */
			flex-direction: row;
			/* Organise les √©l√©ments en ligne (horizontalement) */
			height: 100vh;
			/* Utilise toute la hauteur de la fen√™tre */
		}

		/* Conteneur de la liste des voisins */
		#neighbors-list {
			width: 320px;
			/* Largeur de la colonne des voisins */
			border: 1px solid gray;
			/* Bordure pour s√©parer visuellement */
			padding: 10px;
			/* Ajoute de l‚Äôespace int√©rieur */
			overflow-y: auto;
			/* Barre de d√©filement si la liste est trop longue */
			background-color: #f9f9f9;
			/* Fond l√©g√®rement gris√© */
		}
		
		#graph-title {
		text-align: center;
		font-size: 12px;
		font-weight: bold;
		color: black;
		padding: 10px;
		margin: 0;
		border-bottom: 2px solid #ddd; /* S√©paration avec les listes */
		}

		/* Conteneur Sigma.js */
		#sigma-container {
			flex-grow: 1;
			/* Le graphe occupe l'espace restant */
			border: 1px solid black;
			/* Bordure pour tester visuellement */
		}

		/* Style des √©l√©ments de la liste des voisins */
		#neighbors ul {
			list-style-type: none;
			/* Supprime les puces */
			padding: 0;
		}

		#neighbors li {
			margin-bottom: 5px;
			/* Espace entre les √©l√©ments */
		}

		#neighbors li:hover {
			background-color: #e0e0e0;
			/* Fond en survol */
			cursor: pointer;
			/* Curseur en main */
		}

		/* Style pour le bouton de rechargement */
		#reload-button { 
		position: fixed;
		top: 10px;
		right: 10px;
		background-color: blue !important; /* Supprimer les guillemets */
		color: white !important; /* Le texte en blanc pour contraste */
		border: none;
		padding: 10px 20px;
		font-size: 16px;
		cursor: pointer;
		border-radius: 5px; 
		}

		/* Changement de couleur au survol */
		#reload-button:hover {
		background-color: #45a049 !important;
		}

		/* Conteneur pour la recherche  */
		#search-container {
			flex-direction: column;
			/* Organise les √©l√©ments verticalement */
			gap: 5px;
			/* Augmentation de l'espacement vertical entre les √©l√©ments */
			align-items: center;
			margin-top: 10px; /* Ajoute une marge en haut pour s√©parer du bouton de rechargement */
			margin-bottom: 10px;
			/* Espace entre la recherche et les listes */
		}

		/* Champ de recherche */
		#node-search {
			flex: 1;
			/* Le champ de saisie occupe tout l‚Äôespace disponible */
			padding: 5px;
		}


		/* Message de recherche */
		#search-message {
			margin-top: 10px;
			color: red;
			/* Afficher les messages d'erreur en rouge */
			font-weight: bold;
		}
		
		#search-results {
    list-style-type: none;
    padding: 0;
    margin: 5px 0;
    max-height: 200px;
    overflow-y: auto;
    background: white;
    border: 1px solid #ccc;
    display: none; /* Cach√© par d√©faut */
    position: absolute;
    z-index: 1000;
    width: 200px; /* Ajuste la largeur selon besoin */
}


		
		.reload-btn {
		background-color: #007bff; /* Bleu */
		color: white;             /* Texte blanc */
		padding: 5px 10px;        /* Espacement int√©rieur */
		border: none;              /* Supprimer la bordure */
		border-radius: 5px;        /* Coins arrondis */
		cursor: pointer;     /* Curseur en forme de main */
		margin-top: 10px;		
		font-size:10px;           /* Taille de la police */
		transition: background-color 0.3s ease; /* Animation du changement de couleur */
		}
		
		/* Effet au survol */
		.reload-btn:hover {
		background-color: #0056b3; /* Bleu plus fonc√© au survol */
		}
		
		.toggle-btn {
		background-color: #007bff; /* Bleu */
		color: white;             /* Texte blanc */
		padding: 5px 10px;        /* Espacement int√©rieur */
		border: none;              /* Supprimer la bordure */
		border-radius: 5px;        /* Coins arrondis */
		cursor: pointer;     /* Curseur en forme de main */
		margin-top: 10px;		
		font-size:10px;           /* Taille de la police */
		transition: background-color 0.3s ease; /* Animation du changement de couleur */
		}

		/* Effet au survol */
		.toggle-btn:hover {
		background-color: #0056b3; /* Bleu plus fonc√© au survol */
		}

		/* Style lorsque le bouton est enfonc√© */
		.toggle-btn:active {
		background-color: #003f7f;
		}

		/* Style pour d√©sactiver le bouton */
		.toggle-btn:disabled {
		background-color: #cccccc;
		cursor: not-allowed;
		}
		
		#node-info {
		position: absolute;
		background: rgba(255, 255, 255, 0.99); /* Fond blanc opaque √† 99% */
		color: black; /* Texte en noir pour plus de lisibilit√© */
		border: 2px solid #333; /* Bordure l√©g√®rement fonc√©e */
		padding: 8px;
		border-radius: 5px;
		box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3); /* Ajout d'une ombre pour un effet visuel sympa */
		font-size: 12px;
		max-width: 250px; /* √âvite que la bo√Æte soit trop large */
		z-index: 1000; /* Toujours au-dessus des autres √©l√©ments */
		display: none; /* Cach√© par d√©faut */
		 transform: translateY(15px); /* ‚úÖ D√©cale la bo√Æte 15px vers le bas */
		}
		
		.node-highlight {
		color: red !important;
		font-size: 22px !important;
		font-weight: bold !important;
		transition: color 0.3s ease-in-out, font-size 0.3s ease-in-out;
		}

#left-column {
    width: 300px; /* Largeur fixe de la colonne */
    display: flex;
    flex-direction: column;
    padding: 10px;
    background-color: #f9f9f9; /* Fond clair */
    border-right: 2px solid #ddd; /* S√©paration avec le graphe */
}

#philosopher-info {
	 max-width: 80%; /* R√©duit la largeur pour √©viter de toucher le bord */
    padding: 8px;
    border: 2px solid #333; /* Bordure visible */
    background-color: #fff; /* Fond blanc */
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    color: black;
    border-radius: 8px;
    margin-bottom: 10px; /* Espacement avec la liste des voisins */
	margin-left: auto; /* Centrage horizontal */
    margin-right: auto; /* Centrage horizontal */
}

#philosopher-info a {
    color: red;
    font-size: 18px;
    font-weight: bold;
    text-decoration: none;
}

#philosopher-info img {
    width: 20px;
    height: 20px;
    margin-left: 8px;
    vertical-align: middle;
}



.filter-active {
    background-color: green !important; /* Couleur verte pour montrer que le filtre est actif */
    color: white !important;
}

.filter-message {
    font-size: 12px;
    color: #555;
    margin-top: 5px;
    font-style: italic;
}




#search-input {
    width: 98%;
    height: 60px; /* Permet plusieurs lignes */
    font-size: 14px;
    padding: 5px;
    resize: vertical; /* Permet √† l'utilisateur d'agrandir si n√©cessaire */
}



#filter-container {
    margin-bottom: 5px;
    padding: 10px;
    border: 2px solid #ddd;
    background-color: #f9f9f9;
    text-align: left;
    border-radius: 8px;
    width: 260px;
}

#filter-container label {
    display: inline-block;
    width: 100px; /* Alignement des libell√©s */
    text-align: right;
    margin-right: 5px;
    font-weight: bold;
}

#filter-container input {
     
	width:40px;
    font-size: 14px;
    padding: 5px;
    text-align: center;
}

#filter-container button {
    background-color: lightblue;
    color: white;
    padding: 5px 10px;
    border: none;
    cursor: pointer;
    border-radius: 5px;
    font-size: 12px;
    margin-left: 5px;
	 
}

#filter-container button:hover {
    background-color:  blue;
}

#reset-filter {
    background-color: red;
    margin-top: 10px;
}

#reset-filter:hover {
    background-color: red;
}



	</style>


</head>

<body>

<!-- CHARGEMENT BIBLIOS -->

	<!-- chargement local des bibliotheques qui ont √©t√© t√©l√©charg√© dans le dossier js -->
	<!--<script src="js/graphology.umd.min.js"></script> -->

	<script src="https://unpkg.com/graphology@0.25.2/dist/graphology.umd.min.js"></script>

   <!--  <script src="https://unpkg.com/graphology-traversal/dist/graphology-traversal.min.js"></script>  -->


	<!--  chargement par internet   -->
	<!--  <script src="https://cdn.jsdelivr.net/npm/sigma@2.3.0/build/sigma.min.js"></script>   -->

	<script src="https://unpkg.com/sigma@2.3.0/build/sigma.min.js"></script>

	<!-- LES DONN√âES DATA.JSON SONT DANS LE DOSSIER JS  -->


	<div id="layout-container">
	
		<div id="neighbors-list">
			
			<button class= "reload-btn" onclick="reloadPage()">Revenir au graphe initial complet</button>
			
			<!-- <button class="toggle-btn" onclick="toggleLabels()">Afficher/Masquer d√©tails</button>  ABANDON -->
			
			<div id="node-info" style="position: absolute; top: 92px; left: 15px; width : 150; background: rgba(255, 255, 255, 0.9); border: 4px solid #ccc; padding: 10px; border-radius: 5px; display: none;"></div>

			<div id="fixed-header">
				<div id="search-container">
					<input type="text" id="node-search" placeholder="Rechercher un nom" />
					<button id="search-button">Rechercher</button>
					<ul id="search-results" style="list-style-type: none; padding: 0; margin: 0px 0; max-height: 200px; overflow-y: auto; background: white; border: 2px solid #ccc; display: block;"></ul>


				</div>
			</div>

			<!-- Zone de saisie pour le filtrage -->
<div id="filter-container">
    <label for="modularity-class-input">Modularity Class:</label>
    <input type="text" id="modularity-class-input" placeholder="valeur">

    <label for="degree-total-input">Degr√© Total:</label>
    <input type="text" id="degree-total-input" placeholder="valeur">

    <label for="degree-in-input">Degr√© Entrant:</label>
    <input type="text" id="degree-in-input" placeholder="valeur">

    <label for="degree-out-input">Degr√© Sortant:</label>
    <input type="text" id="degree-out-input" placeholder="valeur">

    <button id="filter-modularity">Filtrer</button>
    <button id="filter-degree-total">Filtrer</button>
    <button id="filter-degree-in">Filtrer</button>
    <button id="filter-degree-out">Filtrer</button>
</div>





			<div id="search-message"></div>
			<h2 id="graph-title" style="text-align: center; margin-bottom: 10px;"></h2>
			
			
			<div id="left-column">
				<!-- ‚úÖ Nouveau placement du cadre Philosophe -->
				<div id="philosopher-info"></div>

				<!-- ‚úÖ Liste des voisins -->
				<h3>Voisins de : <span id="clicked-node-label">cliquez sur un n≈ìud</span></h3>
				<h4>Influenceurs (rouges) :</h4>
				<ul id="influencers-list"></ul>
				<h4>Influenc√©s (bleus) :</h4>
				<ul id="influenced-list"></ul>
			</div>
				
		
		</div>


		<div id="sigma-container"></div>
			
		<!-- Cadre sp√©cifique pour afficher le philosophe et son lien -->
<div id="philosopher-info"></div>


	</div>
		
<script>
	
	// Recharge la page actuelle pour revenir au graphe complet
	function reloadPage() {
        location.reload();
    }

	let renderer; // D√©clare renderer avec une port√©e globale
	
	document.addEventListener("DOMContentLoaded", () => {
		document.getElementById("philosopher-info").textContent = "Cliquez sur un n≈ìud"; // Texte au d√©marrage
	});

	 
	// D√©clarer le graphe principal avec une port√©e globale  
    const maingraph = new window.graphology.Graph();	
	
	
	
///////// FONCTION POUR ATTACHER LES √âCOUTEURS D'√âV√âNEMENTS : CLIC SUR NODE
/////////	permet de recliquer sur les noeuds du sousgraphe 
/////////   dans lequel cette fonction est appel√©e 
    
	function attachEventListeners() {
        // √âcouteur pour les clics sur les n≈ìuds
		renderer.on('clickNode', (event) => {
                const nodeId = event.node; // ID du n≈ìud cliqu√©
				 // Obtenir le label du n≈ìud
                const clickedNodeLabel = renderer.graph.getNodeAttribute(nodeId, 'label');
				console.log ("node cliqu√© = ", nodeId);


		// üìå Mise √† jour du titre "Voisins de :"
			const clickedNodeLabelElement = document.getElementById('clicked-node-label');
			clickedNodeLabelElement.textContent = clickedNodeLabel || `Node ${nodeId}`;

		// üìå Mise √† jour du cadre d√©di√© √† l'affichage du philosophe
			const philosopherInfoElement = document.getElementById('philosopher-info');

		// üí° Supprimer l'ann√©e du label
			const cleanedLabel = clickedNodeLabel.replace(/^\d+\s*/, ""); 

			// üîç V√©rifications console
			console.log("Label nettoy√© :", cleanedLabel);
			console.log("URL Wikipedia :", `https://fr.wikipedia.org/wiki/${encodeURIComponent(cleanedLabel)}`);

   // if (cleanedLabel) {
        // üõ† Cr√©ation du lien Wikip√©dia
        const wikiLink = document.createElement("a");
        wikiLink.href = `https://fr.wikipedia.org/wiki/${encodeURIComponent(cleanedLabel)}`;
        wikiLink.target = "_blank"; // Ouvre dans un nouvel onglet
        wikiLink.textContent = cleanedLabel;
        
        // ‚úÖ Appliquer des styles au lien
        wikiLink.style.color = "red";
        wikiLink.style.fontSize = "22px";
        wikiLink.style.fontWeight = "bold";
        wikiLink.style.textDecoration = "none";

        // üèõ Ajout de l'ic√¥ne Wikip√©dia
        const wikiIcon = document.createElement("img");
        wikiIcon.src = "https://upload.wikimedia.org/wikipedia/commons/6/63/Wikipedia-logo.png";
        wikiIcon.alt = "Wikipedia";
        wikiIcon.style.width = "18px";
        wikiIcon.style.height = "18px";
        wikiIcon.style.marginLeft = "8px";
        wikiIcon.style.verticalAlign = "middle";

        wikiLink.appendChild(wikiIcon); // Ajoute l'ic√¥ne au lien

        // ‚úÖ Met √† jour le cadre `#philosopher-info` sans toucher "Voisins de :"
	   philosopherInfoElement.innerHTML = "";  // Efface le contenu pr√©c√©dent
	   philosopherInfoElement.appendChild(wikiLink); // Ajoute le lien dans le cadre

			// üñ• V√©rification console
			console.log("Philosophe affich√© :", philosopherInfoElement.innerHTML);
		//} 
		//else {
       //		 philosopherInfoElement.textContent = "Aucun philosophe s√©lectionn√©.";
		//}
			console.log ("nodeId =",nodeId);
			
			// Appeler la fonction listevoisins
            listevoisins(nodeId);
            // Appeler la fonction displaySubgraph avec l'ID du n≈ìud cliqu√©
            displaySubgraph(nodeId);
			//appeler la fonction sousgraphe par attribut  
			
			 
        });
	}// FIN DE LA FONCTION ATTACHEVENTLISTENERS 
	
	
/////// ECOUTEUR DU SURVOL DUN NOEUD	////////////////////////////////		
function attachHoverEvents() {
	renderer.on('enterNode', (event) => 
	{
		const nodeId = event.node; // ID du n≈ìud survol√©
		const nodeAttributes = renderer.getGraph().getNodeAttributes(nodeId); // Attributs du n≈ìud
		console.log ("nodeAttributes",nodeAttributes);
		// Construire le contenu √† afficher
			//<strong>Label:</strong> ${nodeAttributes.label || 'N/A'}<br>
			
		const infoHTML = `
			
					<strong>Relations:</strong> ${nodeAttributes.attributes?.['Degr√©'] || 'N/A'}<br> 
					<strong>Influenceurs:</strong> ${nodeAttributes.attributes?.['Degr√© Entrant'] || 'N/A'}<br>
					<strong>Influenc√©s:</strong> ${nodeAttributes.attributes?.['Degr√© Sortant'] || 'N/A'}<br>
					<strong>Groupe n¬∞:</strong> ${nodeAttributes.attributes?.['Modularity Class'] || 'N/A'}<br>
		`;

		// Afficher les informations dans le conteneur
		const infoContainer = document.getElementById('node-info');
		infoContainer.innerHTML = infoHTML;
		infoContainer.style.display = 'block';
	});	// FIN DE L'ENTR√âE SUR LE NOEUD
	
	// SORTIE DU NOEUD
	renderer.on('leaveNode', () =>
	{
		// Masquer les informations lorsque la souris quitte le n≈ìud
		const infoContainer = document.getElementById('node-info');
		infoContainer.style.display = 'none';
	}); // 	FIN DE SORTIE DU NOEUD
	
} // FIN FONCTION attachHoverEvents  SURVOL DE NODES
			
	
	
	
	
	
	
	//////////////////////////////////////////////////////////////////////////////////////////
	//FONCTION AFFICHAGE DU SOUS GRAPHE DES VOISINS DU NOEUD CLIQU√â, voisins dans le graphe principal "maingraph" 
	// declar√©e au debut du script pour avoir une port√©e globale cad pouvoir etre appel√©e de n'importe o√π
	function displaySubgraph(nodeId) {
    //console.log('displaySubgraph called with nodeId:', nodeId);
	
	 // R√©initialiser le conteneur des informations affich√©es
    const infoContainer = document.getElementById('node-info');
    if (infoContainer) {
        infoContainer.style.display = 'none'; // Masquer le conteneur
        infoContainer.innerHTML = '';        // Effacer le contenu
    }

 // V√©rifier si un renderer existe d√©j√†, et le supprimer
    if (renderer) { renderer.kill(); renderer = null; }

    // Cr√©er une nouvelle instance de graphe pour le sous-graphe
    const subgraph = new window.graphology.Graph();
   // console.log(maingraph.getNodeAttributes(nodeId));
	 
    // Ajouter le n≈ìud central au sous-graphe
    subgraph.addNode(nodeId, {
        ...maingraph.getNodeAttributes(nodeId),
        color: 'black',    // Le n≈ìud central est noir
		size: 65,          // Augmenter significativement la taille du n≈ìud
		label: maingraph.getNodeAttribute(nodeId, 'label') || `Node ${nodeId}`,  
		labelSize: 38,     // Augmenter la taille du label
		forceLabel: true   // Force l'affichage du label
    });
	
	const nodecentral = nodeId ;
	
	//console.log ("id du noeud central", nodecentral);
	
		
   // Ajouter les voisins avant d'ajouter les ar√™tes
    maingraph.forEachNeighbor(nodeId, (neighbor) => {
        if (!subgraph.hasNode(neighbor)) {
            subgraph.addNode(neighbor, {
                ...maingraph.getNodeAttributes(neighbor),
                color: 'gray'  // Couleur par d√©faut temporaire pour √™tre mise √† jour apr√®s
            });
        }
    });

    // Ajouter les ar√™tes apr√®s s'√™tre assur√© que les n≈ìuds existent
    maingraph.forEachNeighbor(nodeId, (neighbor) => {
        let color;

        if (maingraph.hasEdge(nodeId, neighbor)) {
            color = 'lightblue';  // Si l'ar√™te part du n≈ìud central vers le voisin
            subgraph.addEdge(nodeId, neighbor, { color });
        }
        if (maingraph.hasEdge(neighbor, nodeId)) {
            color = 'pink';  // Si l'ar√™te vient du voisin vers le n≈ìud central
            subgraph.addEdge(neighbor, nodeId, { color });
        }

        // Mettre √† jour la couleur du voisin selon la direction de l'ar√™te
        subgraph.setNodeAttribute(neighbor, 'color', color);
    });
	
    // R√©cup√©rer le conteneur du graphe
    const container = document.getElementById('sigma-container');

    // Effacer tout le contenu existant
    container.innerHTML = '';

     // Initialiser Sigma avec le sous-graphe et des param√®tres pour agrandir les labels
    renderer = new window.Sigma(subgraph, container, {
		defaultNodeColor: '#FF5733',
		defaultEdgeColor: '#3498DB',
    
		labelSize: 12,              // Taille de base des labels
		labelSizeRatio: 2.0 ,         // Ratio pour ajuster les labels selon la taille des n≈ìuds
		labelThreshold: 0,           // Toujours afficher les labels en fonction du niveau de zoom
		font: 'Arial',               // Utilisation d'une police lisible
		// Faire en sorte que Sigma prenne en compte la couleur du label depuis l'attribut du n≈ìud
		labelColor: { by: 'node', attribute: 'labelColor', default: 'black' },
		minNodeSize: 5,              // Taille minimale des n≈ìuds pour √©viter qu'ils disparaissent
		maxNodeSize: 30,             // Taille maximale pour √©viter qu'ils deviennent trop grands
		minEdgeSize: 1,               // Taille minimale des ar√™tes
		maxEdgeSize: 5,               // Taille maximale des ar√™tes
		zoomingRatio: 1.1,            // R√©glage du zoom plus fin
		enableEdgeHovering: true,      // Activer le survol des ar√™tes
		enableEdgeLabel: true,        // Afficher les labels des ar√™tes si n√©cessaire
		renderLabels: true,           // Forcer l'affichage des labels
		labelRenderedSizeThreshold: 0 // Supprimer le seuil de taille minimal pour afficher tous les labels
	});

	subgraph.forEachNode((node) => {
		subgraph.setNodeAttribute(node, 'size', subgraph.getNodeAttribute(node, 'size') || 10);
		subgraph.setNodeAttribute(node, 'forceLabel', true);
	});
	renderer.getGraph().forEachNode((node) => {
		renderer.getGraph().setNodeAttribute(node, 'size', 8); // Taille par d√©faut

		if (node === nodecentral) {
			renderer.getGraph().setNodeAttribute(node, 'size', 24);  // Taille du n≈ìud central
			renderer.getGraph().setNodeAttribute(node, 'color', 'black'); // Couleur du n≈ìud central
			renderer.getGraph().setNodeAttribute(node, 'labelColor', 'red');  // couleur du label
			renderer.getGraph().setNodeAttribute(nodecentral, 'LabelSize', 20);  // Taille du label personnalis√©e ne fonctionne pas 
    }
	});
	
	//titre du graphe
	document.getElementById('graph-title').textContent = `Graphe des voisins de ${renderer.getGraph().getNodeAttribute(nodeId, 'label-court')} =>`;
	
		
		
	renderer.refresh();

    //console.log('Sous-graphe des voisins affich√©');
	
	// R√©attachement des √©v√©nements apr√®s affichage du sous-graphe
	attachEventListeners();
	attachHoverEvents();
				
	}; //----------------------------------------- FIN DE FUNCTION DISPLAYSUBGRAPH
	///////////////////////////////////////////////////////////////////////////////
	
	
	
	
	//Fonction pour mettre √† jour les listes de voisins
	function updateNeighborList(label, nodeId, influencersList, influencedList) {
    const influencerItems = influencersList.getElementsByTagName('li');
    const influencedItems = influencedList.getElementsByTagName('li');

    for (let item of influencerItems) {
        if (item.getAttribute('data-node-id') === nodeId.toString()) {
            item.textContent = label;  // Mise √† jour du texte dans la liste des influenceurs
        }
    }

    for (let item of influencedItems) {
        if (item.getAttribute('data-node-id') === nodeId.toString()) {
            item.textContent = label;  // Mise √† jour du texte dans la liste des influenc√©s
        }
    }
}  // fin de la fonction updateNeighborList

	
	
////////////////////////////////////////////////////////////////////////	
//// FONCTION LISTES DES VOISINS
	function listevoisins(nodeId) {
    // Obtenir le label du n≈ìud cliqu√©
    const clickedNodeLabel = maingraph.getNodeAttribute(nodeId, 'label'); 
    const clickedNodeLabelElement = document.getElementById('clicked-node-label');
    clickedNodeLabelElement.textContent = clickedNodeLabel || `Node ${nodeId}`;

    // R√©cup√©rer toutes les ar√™tes associ√©es au n≈ìud cliqu√©
    const edges = maingraph.edges(nodeId);

    // Initialiser les listes pour les influenceurs et influenc√©s
    const influencersList = document.getElementById('influencers-list');
    const influencedList = document.getElementById('influenced-list');

    influencersList.innerHTML = ''; // R√©initialise la liste des influenceurs
    influencedList.innerHTML = '';  // R√©initialise la liste des influenc√©s

    let influencers = [];
    let influenced = [];

    // Parcourt les ar√™tes pour classer les voisins
    edges.forEach(edgeId => {
        const source = maingraph.source(edgeId);  // Source de l'ar√™te
        const target = maingraph.target(edgeId);  // Cible de l'ar√™te

        if (target === nodeId) {
            // Ajouter √† la liste des influenceurs avec l'ann√©e de naissance
            const influencerLabel = maingraph.getNodeAttribute(source, 'label') || `Node ${source}`;
            const birthYear = parseInt(influencerLabel.split(' ')[0]) || 9999;  // Extraction de l'ann√©e
            influencers.push({ id: source, label: influencerLabel, year: birthYear });
        } else if (source === nodeId) {
            // Ajouter √† la liste des influenc√©s avec l'ann√©e de naissance
            const influencedLabel = maingraph.getNodeAttribute(target, 'label') || `Node ${target}`;
            const birthYear = parseInt(influencedLabel.split(' ')[0]) || 9999;  // Extraction de l'ann√©e
            influenced.push({ id: target, label: influencedLabel, year: birthYear });
        }
    });

    // Trier les listes par ann√©e de naissance croissante
    influencers.sort((a, b) => a.year - b.year);
    influenced.sort((a, b) => a.year - b.year);

    // Ajouter les influenceurs tri√©s dans la liste HTML
    influencers.forEach((influencer) => {
        const li = document.createElement('li');
        li.textContent = influencer.label;
        li.setAttribute('data-node-id', influencer.id);
        influencersList.appendChild(li);
    });

    // Ajouter les influenc√©s tri√©s dans la liste HTML
    influenced.forEach((influencedNode) => {
        const li = document.createElement('li');
        li.textContent = influencedNode.label;
        li.setAttribute('data-node-id', influencedNode.id);
        influencedList.appendChild(li);
    });
} // FIN DE LA FONCTION LISTE DES VOISINS
//////////////////////////////////////////////////////////////////////
		
		
	// CHARGEMENT DES DONN√âES ET CONSTRUCTION DU GRAPHE DES VOISINS

	// Attendre que le DOM soit compl√®tement charg√©  
	document.addEventListener('DOMContentLoaded', () => {  // ferm√© en derniere ligne du script
		
		
		// verifications du chargement de Sigma
		if (window.Sigma) {
				//console.log("Sigma.js est bien charg√© ");
				//console.log("Propri√©t√©s disponibles dans Sigma.js :", Object.keys(window.Sigma));
		} else {console.log("Sigma.js n'est pas charg√© !");	};
			// essai pour avoir la version de sigma (pas tjs pr√©sente)
			//if ( window.Sigma.version) {console.log("Version de Sigma.js :", window.Sigma.version);} 
			//else {console.log("Impossible de d√©tecter la version de Sigma.js");	};
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// UTILISATION DE FETCH POUR CHARGER LES DONN√âES DEPUIS LE DOSSIER ./js
		fetch('./js/degre.json')
		.then(response => {
				// V√©rifier si la r√©ponse est obtenue
				if (!response.ok) { console.log("pas de reponse √† fetch" );	}				
				// Parser la r√©ponse JSON qui va devenir un ogjet javascript utilisable
				return response.json();
		})
		
		.then(data =>
		{   
			try 
			{  								//utilisation de maingraph d√©clar√© global
				// IT√âRER SUR LES N≈íUDS
				data.nodes.forEach(node =>
				{
					if (!node.id) {
						console.error(`Node is missing   id. Skipping.`);
						return;
					}
					// Convertir les coordonn√©es x et y en nombres flottants
						node.x = parseFloat(node.x);
						node.y = parseFloat(node.y);
						//console.log("N≈ìud actuel :", node);

	
					// Mise √† jour du label avec des attributs suppl√©mentaires existant dans les data
						//const degreeIn = node['Degr√© Entrant'] || 'N/A';
						//const degreeOut = node['Degr√© Sortant'] || 'N/A';
						const degreeIn = node.attributes?.['Degr√© Entrant'] || 'N/A';
						const degreeOut = node.attributes?.['Degr√© Sortant'] || 'N/A';
						const degree = node.attributes?.['Degr√©'] || 'N/A';
						const modularityClass = node.attributes?.['Modularity Class'] || 'N/A';

//console.log(`Noeud ${node.label} - Degr√© Entrant:`, degreeIn);
//console.log(`Noeud ${node.label} - Degr√© Sortant:`, degreeOut);
//console.log(`Noeud ${node.label} - Degr√©:`, degree);
//console.log(`Noeud ${node.label} - Modularity Class:`, modularityClass);

						
						// Stocker les labels court et long
						node['label-court'] = node.label;  
						node['label-long'] = `${node.label}, In ${degreeIn}, Out ${degreeOut}  `;

						// Par d√©faut, afficher le label court
						node.label = node['label-court'];
								
						// Ajouter le n≈ìud au graphe
							maingraph.addNode(node.id, node);
							//console.log("tyty",node); // Should print the node
							
							
				});
							
								
				// IT√âRER SUR LES AR√äTES
				data.edges.forEach(edge =>
				{
					if (!edge.source || !edge.target) {
						console.error(`Edge is missing source or target. Skipping.`);
						return;
					}
								
					// AJOUTER LES ANN√âES DE NAISSANCE AUX N≈íUDS SOURCE ET TARGET
						//maingraph.setNodeAttribute(edge.source, 'birthYear', edge.ans || 'N/A');
						//maingraph.setNodeAttribute(edge.target, 'birthYear', edge.ant || 'N/A');
					 maingraph.setNodeAttribute(edge.source, 'birthYear', edge.attributes?.ans || 'N/A');
					maingraph.setNodeAttribute(edge.target, 'birthYear', edge.attributes?.ant || 'N/A');

					//console.log(`Noeud ${edge.source} - birthYear:`, maingraph.getNodeAttribute(edge.source, 'birthYear'));
					//console.log(`Noeud ${edge.target} - birthYear:`, maingraph.getNodeAttribute(edge.target, 'birthYear'));

					
					// Ajouter l'ar√™te au graphe avec les attributs
					maingraph.addEdge(edge.source, edge.target,
					{
						type: 'arrow', // Type d'ar√™te (fl√®che)
						edgeThickness: 0.1, // Contr√¥le direct de l'√©paisseur (en pixels)
						color: 'lightblue', // Couleur de l'ar√™te
						...edge.attributes || {} // Propagation des attributs optionnels de l'ar√™te
												//ou un objet vide pour √©viter les erreurs
					});
						//console.log("edge",edge); // Should print the edge
				});
								
			// ITERER A NOUVEAU SUR LES NOEUD POUR AJOUTER BIRTHYEAR QUI A √âT√â CR√â√â DANS LA BOUCLE DES EDGE
				data.nodes.forEach(node =>
				{ 
					// R√©cup√©rer l'ann√©e de naissance ajout√©e depuis les ar√™tes
					//et redefinir les autres attributs
					const An = node['birthYear'] || 'N/A';
						const degreeIn = node.attributes?.['Degr√© Entrant'] || 'N/A';
						const degreeOut = node.attributes?.['Degr√© Sortant'] || 'N/A';
						const degree = node.attributes?.['Degr√©'] || 'N/A';
						const modularityClass = node.attributes?.['Modularity Class'] || 'N/A';

					// Mise √† jour du label avec l'ann√©e au d√©but
					node.label = `${An} ${node.label}`;

					// Mise √† jour du label long en ajoutant toutes les informations
					node['label-long'] = `${node.label}, An ${An}, In ${degreeIn}, Out ${degreeOut}, Class ${modularityClass} `;
					//console.log( node['label-long'] );
				});

				// R√©cup√©rer le conteneur du graphe
					const container = document.getElementById('sigma-container');
			
				// Cr√©er le rendu Sigma.js
					renderer = new window.Sigma.Sigma( maingraph, container,
					{    
						// minEdgeSize: edgeSize, // Taille minimale des ar√™tes (pour une taille constante)
						//maxEdgeSize: edgeSize, // Taille maximale des ar√™tes (pour une taille constante)
						defaultEdgeType: "arrow", // Type d'ar√™te par d√©faut
						edgeColor: 'lightblue'
					});
					//console.log("Renderer cr√©√© :", renderer); // V√©rification ABSOLUMENT cruciale
					if (!renderer) {
					console.error("Le rendu n'a pas √©t√© cr√©√© ! V√©rifiez le conteneur et l'initialisation de Sigma.")};
		
		
					// Ajuster la taille des fl√®ches
					renderer.setSetting("edgeArrowSizeRatio", 10);  // ne marche pas
								
					renderer.on('zoom', event =>
					{
						const zoomLevel = event.data.camera.ratio; // Niveau de zoom
						const baseThickness = 0.1; // √âpaisseur de base
						const thickness = baseThickness / zoomLevel; // Ajuster selon le zoom                   
						maingraph.edges().forEach( edge =>
						{
							maingraph.setEdgeAttribute(edge, 'edgeThickness', thickness);
						});
						// Rafra√Æchir le rendu (important apr√®s la cr√©ation du graphe)
							renderer.refresh();
					});
	
	
	// ‚úÖ R√©attacher les √©v√©nements pour permettre le survol et le clic
    attachEventListeners();
	attachHoverEvents();
	
	
	// 2Ô∏è‚É£ Fonction de filtrage √† ajouter apr√®s l'initialisation du graphe
	
	function filterGraph(attribute, inputId) {
   

   const input = document.getElementById(inputId);
    if (!input) {
        console.error(`‚ùå Erreur : Impossible de trouver l'√©l√©ment ${inputId}`);
        return;
    }
    
    const value = input.value.trim();
    
    if (!value) { // Si le champ est vide, on n'applique pas le filtre
        console.log(`üü¢ Aucun filtre appliqu√© pour ${attribute}`);
        return;
    }

    console.log(`üéØ Filtrage appliqu√© : ${attribute} = ${value}`);
    applyFilter(attribute, value);


	
	
	//function filterGraph(attribute, value) {
    if (!value) {
        alert(`Veuillez entrer une valeur pour ${attribute}.`);
        return;
    }

    console.log(`Filtrage sur ${attribute} = ${value}`);

    const subgraph = new graphology.Graph();

    // Filtrer les n≈ìuds existants
    renderer.getGraph().forEachNode((nodeId, attributes) => {
        if (attributes.attributes && attributes.attributes[attribute] == value) {
            subgraph.addNode(nodeId, { ...attributes });
        }
    });

    // Filtrer les ar√™tes associ√©es aux n≈ìuds s√©lectionn√©s
    renderer.getGraph().forEachEdge((edgeId, attributes, source, target) => {
        if (subgraph.hasNode(source) && subgraph.hasNode(target)) {
            subgraph.addEdge(source, target, { ...attributes });
        }
    });

    console.log(`Nombre de n≈ìuds trouv√©s : ${subgraph.order}`);
    console.log(`Nombre d'ar√™tes trouv√©es : ${subgraph.size}`);

    if (subgraph.order === 0) {
        alert(`Aucun √©l√©ment trouv√© avec ${attribute} = ${value}`);
        return;
    }

    // Afficher uniquement le sous-graphe correspondant
    const container = document.getElementById('sigma-container');
container.innerHTML = ''; // Efface le graphe pr√©c√©dent

renderer = new window.Sigma(subgraph, container);
renderer.refresh();

    // ‚úÖ R√©attacher les √©v√©nements pour permettre le survol et le clic
    attachEventListeners();
	attachHoverEvents();
	
	
	
	
	
	
}
// 3Ô∏è‚É£ Associer les boutons de filtrage aux fonctions correspondantes

document.getElementById("filter-modularity")?.addEventListener("click", () => {
    filterGraph("Modularity Class", "modularity-class-input");
});

document.getElementById("filter-degree-total")?.addEventListener("click", () => {
    filterGraph("Degr√©", "degree-total-input");
});

document.getElementById("filter-degree-in")?.addEventListener("click", () => {
    filterGraph("Degr√© Entrant", "degree-in-input");
});

document.getElementById("filter-degree-out")?.addEventListener("click", () => {
    filterGraph("Degr√© Sortant", "degree-out-input");
});


	function removeFilter(attribute) {
    console.log(`üóëÔ∏è Suppression du filtre : ${attribute}`);
    initializeFilters(); // R√©initialise les champs de saisie
}

	
	
	
	
/////// √âCOUTEUR POUR LES CLICS SUR LES N≈íUDS
	renderer.on('clickNode', (event) => {
	
	// Obtenir le label du n≈ìud
                const clickedNodeLabel = renderer.graph.getNodeAttribute(event.node, 'label');
				console.log ("node cliqu√© = ", event.node);
	
	// üìå Mise √† jour du cadre d√©di√© √† l'affichage du philosophe
			const philosopherInfoElement = document.getElementById('philosopher-info');

		// üí° Supprimer l'ann√©e du label
			const cleanedLabel = clickedNodeLabel.replace(/^\d+\s*/, ""); 

			// üîç V√©rifications console
			console.log("Label nettoy√© :", cleanedLabel);
			console.log("URL Wikipedia :", `https://fr.wikipedia.org/wiki/${encodeURIComponent(cleanedLabel)}`);

   // if (cleanedLabel) {
        // üõ† Cr√©ation du lien Wikip√©dia
        const wikiLink = document.createElement("a");
        wikiLink.href = `https://fr.wikipedia.org/wiki/${encodeURIComponent(cleanedLabel)}`;
        wikiLink.target = "_blank"; // Ouvre dans un nouvel onglet
        wikiLink.textContent = cleanedLabel;
        
        // ‚úÖ Appliquer des styles au lien
        wikiLink.style.color = "red";
        wikiLink.style.fontSize = "22px";
        wikiLink.style.fontWeight = "bold";
        wikiLink.style.textDecoration = "none";

        // üèõ Ajout de l'ic√¥ne Wikip√©dia
        const wikiIcon = document.createElement("img");
        wikiIcon.src = "https://upload.wikimedia.org/wikipedia/commons/6/63/Wikipedia-logo.png";
        wikiIcon.alt = "Wikipedia";
        wikiIcon.style.width = "18px";
        wikiIcon.style.height = "18px";
        wikiIcon.style.marginLeft = "8px";
        wikiIcon.style.verticalAlign = "middle";

        wikiLink.appendChild(wikiIcon); // Ajoute l'ic√¥ne au lien

        // ‚úÖ Met √† jour le cadre `#philosopher-info` sans toucher "Voisins de :"
       


	   philosopherInfoElement.innerHTML = "";  // Efface le contenu pr√©c√©dent
     

	   philosopherInfoElement.appendChild(wikiLink); // Ajoute le lien dans le cadre
	
	
	
				
			// Appeler la fonction displaySubgraph  
				displaySubgraph(event.node);
				
			// appel de la fonction listevoisins
			    listevoisins(event.node, maingraph);
						
	}) ; //////// FIN DE √âCOUTEUR POUR LES CLICS SUR LES N≈íUDS
	
		
		 // ecouteur pour les Clic sur le fond du subgraphe pour r√©afficher le maingraph
	     //  renderer.on('clickStage', () => {location.reload();});  PAS AU POINT
			
		
		
	
///////////////////////////////////////////////////////////////////
// FONCTION POUR CREER LE GRAPHE DES NOEUDS AYANT LE MEME ATTRIBUT
	
// FIN DE LA FONCTION createSubgraphByAttribute


	// FONCTION AFFICHAGE DES NOEUDS ET ARETES DU GRAPHE PAR ATTRIBUT ET VALEUR
	 // FIN DE LA FONCTION SELECTION DES NOEUDS ET ARETES DU GRAPHE PAR ATTRIBUT


	// FONCTION POUR APPLIQUER LE FILTRE VIA L'INTERFACE UTILISATEUR
	// LA FONCTION APPLYFILTER EST APPEL√âE DANS LE BOUTON "AFFICHER LE SOUS GRAPHE"
	
	// Attacher explicitement la fonction √† l'objet global
       function applyFilter(attribute, value) {
    if (!attribute || value === null || value === undefined || value.trim() === "") {
        console.error("‚ùå Erreur : Attribut ou valeur invalide dans applyFilter", { attribute, value });
        alert("Veuillez entrer une valeur correcte pour appliquer le filtre.");
        return;
    }
    
    if (!renderer || typeof renderer.getGraph !== "function") {
        console.error("‚ùå Renderer non d√©fini ou graph introuvable");
        return;
    }
    
    console.log(`‚úÖ Application du filtre : ${attribute} = ${value}`);

    const subgraph = new graphology.Graph();

    renderer.getGraph().forEachNode((nodeId, attributes) => {
        if (attributes.attributes && attributes.attributes[attribute] !== undefined && attributes.attributes[attribute] == value) {
            subgraph.addNode(nodeId, { ...attributes });
        }
    });

    renderer.getGraph().forEachEdge((edgeId, attributes, source, target) => {
        if (subgraph.hasNode(source) && subgraph.hasNode(target)) {
            subgraph.addEdge(source, target, { ...attributes });
        }
    });

    if (subgraph.order === 0) {
        console.warn(`‚ö†Ô∏è Aucun √©l√©ment trouv√© avec ${attribute} = ${value}`);
        alert(`Aucun √©l√©ment trouv√© avec ${attribute} = ${value}`);
        return;
    }

    renderer.setGraph(subgraph);
    renderer.refresh();
    console.log(`‚úÖ Sous-graphe mis √† jour avec ${attribute} = ${value}`);
}

	// FIN DE LA FONCTION POUR APPLIQUER LE FILTRE	


	
	// CODE POUR UTILISER LE BOUTON DE RECHERCHE D'UN NOEUD PAR SOUSCHAINE DU LABEL		
	// Gestionnaire pour la recherche du noeud par nom=label dans bouton
	
	document.getElementById("search-button").addEventListener("click", function() {
    const searchTerm = document.getElementById("node-search").value.trim().toLowerCase();
    
    const results = [];

	const searchResultsContainer = document.getElementById("search-results");

    if (!searchResultsContainer) return; // V√©rifier si la liste existe

    searchResultsContainer.innerHTML = ""; // Nettoyer la liste pr√©c√©dente
    searchResultsContainer.style.display = "block"; // Assurer l'affichage

    // Recherche dans `maingraph` pour proposer des suggestions
    maingraph.forEachNode((nodeId, attributes) => {
        if (attributes.label.toLowerCase().includes(searchTerm)) {
            results.push({ id: nodeId, label: attributes.label });
        }
    });

	if (!searchTerm) { searchResultsContainer.innerHTML = `<li style="color: red;">Saisir des caract√®res</li>`;
        return;
	}
    if (results.length === 0) {
        searchResultsContainer.innerHTML = `<li style="color: red;">Aucun r√©sultat trouv√©</li>`;
        return;
    }

    results.forEach(node => {
        const listItem = document.createElement("li");
        listItem.textContent = node.label;
        listItem.style.cursor = "pointer";
        listItem.style.padding = "5px";
        listItem.style.borderBottom = "1px solid #ccc";
        listItem.addEventListener("click", function() {
            // console.log(` S√©lection de ${node.label}, affichage du graphe et masquage de la liste.`);
			
			//  Masquer la liste apr√®s s√©lection
          
			searchResultsContainer.style.display = 'none';
			
			            
            //  Afficher le graphe et les voisins du n≈ìud cliqu√©
            afficherNoeud(node.id);
        });

        searchResultsContainer.appendChild(listItem);
    });
});// FIN DE RECHERCHE D'UN NOEUD PAR SOUSCHAINE DU LABEL


 

// AFFICHAGE GRAPHE ET LISTE DU NOEUD CLIQU√â DANS LA LISTE de resultat de la recherche
// par souschaine de caracteres
function afficherNoeud(nodeId) {
   //console.log(`Affichage du graphe et des listes de voisins pour ${nodeId}`);

	// V√©rifier si le n≈ìud existe dans le graphe initial `maingraph`
    if (!maingraph.hasNode(nodeId)) {
        console.warn(`‚ùå Le n≈ìud ${nodeId} n'existe pas dans le graphe principal.`);
        return;
	}
	else
	{
     // Met √† jour le titre de la colonne de gauche
    document.getElementById("graph-title").textContent = `Voisins de ${maingraph.getNodeAttribute(nodeId, "label")}`;

    // Met √† jour la liste des voisins en utilisant `maingraph`
    listevoisins(nodeId, maingraph); 

    // Affiche le sous-graphe depuis `maingraph`
    displaySubgraph(nodeId, maingraph);
	 }
} //FIN DE afficherNoeud




		} //FIN DU TRY
		catch (error) { console.error("Erreur lors de la cr√©ation du graphe:", error); }
  
	});  // FIN DU .THEN(DATA =>
		
});  // FIN DE DOCUMENT.ADDEVENTLISTENER('DOMCONTENTLOADED', 

 	 
	document.addEventListener("mousemove", (event) => {
    const infoContainer = document.getElementById("node-info");
		if (infoContainer && infoContainer.style.display === "block") {
			infoContainer.style.top = `${event.clientY + 15}px`;
			infoContainer.style.left = `${event.clientX + 15}px`;
		}
	});
</script>




<script>


// ‚úÖ Mode test pour activer/d√©sactiver les nouvelles fonctionnalit√©s de filtre
const testNewFilterSystem = true; // Passe √† false pour garder l'ancien comportement

// ‚úÖ Initialisation des filtres au chargement de la page
document.addEventListener("DOMContentLoaded", () => {
    setTimeout(initializeFilters, 500); // Assurer que les √©l√©ments sont charg√©s
});

// ‚úÖ Initialisation des filtres avec un champ vide par d√©faut
function initializeFilters() {
    console.log("üîÑ Initialisation des filtres...");
    
    const filters = [
        "modularity-class-input",
        "degree-total-input",
        "degree-in-input",
        "degree-out-input"
    ];

    filters.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.value = ""; // Champ vide par d√©faut
        } else {
            console.error(`‚ùå Erreur : Impossible de trouver l'√©l√©ment ${id}`);
        }
    });
    
    console.log("‚úÖ Filtres initialis√©s avec un champ vide");
}

// ‚úÖ Fonction pour g√©rer les filtres avec la nouvelle gestion
function filterGraph(attribute, inputId) {
    const input = document.getElementById(inputId);
    if (!input) {
        console.error(`‚ùå Erreur : Impossible de trouver l'√©l√©ment ${inputId}`);
        return;
    }
    
    const value = input.value.trim();
    if (!value) { // Si le champ est vide, on n'applique pas le filtre
        console.log(`üü¢ Aucun filtre appliqu√© pour ${attribute}`);
        return;
    }

    console.log(`üéØ Filtrage appliqu√© : ${attribute} = ${value}`);
    applyFilter(attribute, value);
}

// ‚úÖ Appliquer le filtre sur le graphe
function applyFilter(attribute, value) {
    if (!renderer || typeof renderer.getGraph !== "function") {
        console.error("‚ùå Renderer non d√©fini ou graph introuvable");
        return;
    }
    
    const subgraph = new graphology.Graph();

    renderer.getGraph().forEachNode((nodeId, attributes) => {
        if (attributes.attributes && attributes.attributes[attribute] !== undefined && attributes.attributes[attribute] == value) {
            subgraph.addNode(nodeId, { ...attributes });
        }
    });

    renderer.getGraph().forEachEdge((edgeId, attributes, source, target) => {
        if (subgraph.hasNode(source) && subgraph.hasNode(target)) {
            subgraph.addEdge(source, target, { ...attributes });
        }
    });

    if (subgraph.order === 0) {
        console.warn(`‚ö†Ô∏è Aucun √©l√©ment trouv√© avec ${attribute} = ${value}`);
        alert(`Aucun √©l√©ment trouv√© avec ${attribute} = ${value}`);
        return;
    }

    renderer = new window.Sigma(subgraph, document.getElementById('sigma-container'), {
        defaultNodeColor: '#FF5733',
        defaultEdgeColor: '#3498DB',
        labelSize: 12,
        labelSizeRatio: 2.0,
        labelThreshold: 0,
        font: 'Arial',
        labelColor: { by: 'node', attribute: 'labelColor', default: 'black' },
        minNodeSize: 5,
        maxNodeSize: 30,
        minEdgeSize: 1,
        maxEdgeSize: 5,
        zoomingRatio: 1.1,
        enableEdgeHovering: true,
        enableEdgeLabel: true,
        renderLabels: true,
        labelRenderedSizeThreshold: 0
    });
    renderer.refresh();
    console.log(`‚úÖ Sous-graphe mis √† jour avec ${attribute} = ${value}`);
}

// ‚úÖ Ajouter les √©couteurs d'√©v√©nements pour activer les filtres
if (testNewFilterSystem) {
    document.getElementById("filter-modularity")?.addEventListener("click", () => {
        filterGraph("Modularity Class", "modularity-class-input");
    });

    document.getElementById("filter-degree-total")?.addEventListener("click", () => {
        filterGraph("Degr√©", "degree-total-input");
    });

    document.getElementById("filter-degree-in")?.addEventListener("click", () => {
        filterGraph("Degr√© Entrant", "degree-in-input");
    });

    document.getElementById("filter-degree-out")?.addEventListener("click", () => {
        filterGraph("Degr√© Sortant", "degree-out-input");
    });
}


</script>


</body>
</html>

	 
 